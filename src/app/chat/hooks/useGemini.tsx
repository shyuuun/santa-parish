import { useRef } from "react";
import { GoogleGenAI, Chat, Type } from "@google/genai";
import { SYSTEM_INSTRUCTIONS } from "../instructions";
import { createClient } from "@/src/utils/supabase/cilent";

interface UseGeminiOptions {
	model?: string;
}

interface LoanApplicationParams {
	loan_type: string;
	amount_requested: number;
	purpose_loan: string;
	term_months: number;
}

export function useGemini({ model = "gemini-2.5-flash" }: UseGeminiOptions) {
	const GEMINI_API_KEY = process.env.NEXT_PUBLIC_GEMINI_API || "";

	const aiRef = useRef<GoogleGenAI | null>(null);
	const chatRef = useRef<Chat | null>(null);

	if (aiRef.current === null) {
		aiRef.current = new GoogleGenAI({ apiKey: GEMINI_API_KEY });
	}

	// Function to calculate loan amortization
	const calculateLoanAmortization = (principal: number, termMonths: number, monthlyRate: number = 0.025) => {
		// Calculate monthly payment using diminishing balance formula
		const monthlyPayment = principal * (monthlyRate * Math.pow(1 + monthlyRate, termMonths)) / (Math.pow(1 + monthlyRate, termMonths) - 1);
		
		const schedule = [];
		let remainingBalance = principal;
		let totalInterest = 0;

		for (let month = 1; month <= termMonths; month++) {
			const interestPayment = remainingBalance * monthlyRate;
			const principalPayment = monthlyPayment - interestPayment;
			remainingBalance = Math.max(0, remainingBalance - principalPayment);
			totalInterest += interestPayment;

			schedule.push({
				month,
				payment: monthlyPayment,
				interest: interestPayment,
				principal: principalPayment,
				balance: remainingBalance
			});
		}

		return {
			monthlyPayment,
			totalPayments: monthlyPayment * termMonths,
			totalInterest,
			schedule
		};
	};

	// Function to save loan application
	const saveLoanApplication = async (params: LoanApplicationParams) => {
		try {
			const supabase = createClient();
			
			// Get current user
			const { data: { user }, error: userError } = await supabase.auth.getUser();
			if (userError || !user) {
				throw new Error("User not authenticated");
			}

			// Insert loan application
			const { error } = await supabase
				.from("loan_applications")
				.insert([{
					applicant_id: user.id,
					loan_type: params.loan_type,
					amount_requested: params.amount_requested,
					purpose_loan: `${params.purpose_loan} (generated by Santa Parish AI)`,
					app_status: "pending"
				}]);

			if (error) {
				throw new Error(`Failed to save loan application: ${error.message}`);
			}

			// Calculate loan details for response
			const loanCalculation = calculateLoanAmortization(params.amount_requested, params.term_months);
			
			// Calculate deductions (7% total)
			const shareCapital = params.amount_requested * 0.02; // 2%
			const savingsDeposit = params.amount_requested * 0.02; // 2%
			const serviceFee = params.amount_requested * 0.03; // 3%
			const netCashReceived = params.amount_requested - (shareCapital + savingsDeposit + serviceFee);

			return { 
				success: true, 
				message: "Loan application saved successfully!",
				calculation: loanCalculation,
				deductions: {
					shareCapital,
					savingsDeposit,
					serviceFee,
					netCashReceived
				}
			};
		} catch (error) {
			console.error("Error saving loan application:", error);
			return { success: false, message: error instanceof Error ? error.message : "Failed to save loan application" };
		}
	};

	// Define available functions for the AI
	const functions = [
		{
			name: "save_loan_application",
			description: "Save a loan application when the user asks about getting a loan with specific amount and term",
			parameters: {
				type: Type.OBJECT,
				properties: {
					loan_type: {
						type: Type.STRING,
						enum: ["personal", "business", "emergency", "home_improvement", "education"],
						description: "Type of loan requested"
					},
					amount_requested: {
						type: Type.NUMBER,
						description: "Amount of loan requested in pesos"
					},
					purpose_loan: {
						type: Type.STRING,
						description: "Purpose or reason for the loan"
					},
					term_months: {
						type: Type.NUMBER,
						description: "Loan term in months"
					}
				},
				required: ["loan_type", "amount_requested", "purpose_loan", "term_months"]
			}
		}
	];

	/**
	 * Streams the response from Gemini as an async generator.
	 * @param history The conversation history
	 */
	type GeminiMessage = { from: "user" | "bot"; text: string };

	const streamPrompt = async function* (
		history: GeminiMessage[]
	): AsyncGenerator<string, void, unknown> {
		try {
			// Get the latest user message
			const latestUserMessage = history[history.length - 1];
			if (!latestUserMessage || latestUserMessage.from !== "user") {
				yield "No user message found.";
				return;
			}

			// Create or get existing chat session
			if (!chatRef.current) {
				// Convert history to proper format for initial chat creation
				// Exclude the latest user message since we'll send it separately
				const chatHistory = history.slice(0, -1).map((msg) => ({
					role:
						msg.from === "user"
							? ("user" as const)
							: ("model" as const),
					parts: [{ text: msg.text }],
				}));

				chatRef.current = await aiRef.current!.chats.create({
					model: model,
					config: {
						systemInstruction: SYSTEM_INSTRUCTIONS,
						tools: [{
							functionDeclarations: functions
						}]
					},
					history: chatHistory,
				});
			}

			// Send the latest message and stream the response
			const stream = await chatRef.current.sendMessageStream({
				message: [{ text: latestUserMessage.text }],
			});

			// Process the stream
			for await (const chunk of stream) {
				// Check if the chunk contains function calls
				const functionCalls = chunk.candidates?.[0]?.content?.parts?.filter(part => part.functionCall);
				
				if (functionCalls && functionCalls.length > 0) {
					// Handle function calls
					for (const functionCall of functionCalls) {
						if (functionCall.functionCall?.name === "save_loan_application") {
							const args = functionCall.functionCall.args;
							
							// Safely extract parameters
							const params: LoanApplicationParams = {
								loan_type: args?.loan_type as string || "personal",
								amount_requested: Number(args?.amount_requested) || 0,
								purpose_loan: args?.purpose_loan as string || "General purpose",
								term_months: Number(args?.term_months) || 12
							};
							
							const result = await saveLoanApplication(params);
							
							if (result.success) {
								yield `\n\nâœ… **Loan Application Saved!**\n\n`;
								yield `I've automatically saved your loan application with the following details:\n\n`;
								
								// Loan details
								yield `## ðŸ“‹ **Loan Application Details**\n`;
								yield `- **Amount Requested:** â‚±${params.amount_requested.toLocaleString()}\n`;
								yield `- **Term:** ${params.term_months} months\n`;
								yield `- **Type:** ${params.loan_type}\n`;
								yield `- **Purpose:** ${params.purpose_loan}\n`;
								yield `- **Interest Rate:** 2.5% monthly (diminishing balance)\n\n`;
								
								// Deductions breakdown
								yield `## ðŸ’° **Deductions from Loan Amount**\n`;
								yield `- **Share Capital (2%):** â‚±${result.deductions?.shareCapital.toLocaleString()}\n`;
								yield `- **Savings Deposit (2%):** â‚±${result.deductions?.savingsDeposit.toLocaleString()}\n`;
								yield `- **Service Fee (3%):** â‚±${result.deductions?.serviceFee.toLocaleString()}\n`;
								yield `- **Net Cash You'll Receive:** â‚±${result.deductions?.netCashReceived.toLocaleString()}\n\n`;
								
								// Payment summary
								yield `## ðŸ“Š **Payment Summary**\n`;
								yield `- **Monthly Payment:** â‚±${result.calculation?.monthlyPayment.toFixed(2)}\n`;
								yield `- **Total Amount to Pay:** â‚±${result.calculation?.totalPayments.toFixed(2)}\n`;
								yield `- **Total Interest:** â‚±${result.calculation?.totalInterest.toFixed(2)}\n\n`;
								
								// Amortization table
								yield `## ðŸ“… **Payment Schedule (Amortization Table)**\n\n`;
								yield `| Month | Payment | Interest | Principal | Balance |\n`;
								yield `|-------|---------|----------|-----------|----------|\n`;
								
								if (result.calculation?.schedule) {
									for (const payment of result.calculation.schedule) {
										yield `| ${payment.month} | â‚±${payment.payment.toFixed(2)} | â‚±${payment.interest.toFixed(2)} | â‚±${payment.principal.toFixed(2)} | â‚±${payment.balance.toFixed(2)} |\n`;
									}
								}
								
								yield `\n---\n\n`;
								yield `ðŸ“Œ **Next Steps:**\n`;
								yield `- Your application is now **pending approval**\n`;
								yield `- Approval typically takes **1-2 business days**\n`;
								yield `- You can check your application status at [/home/loans](/home/loans)\n`;
								yield `- You'll receive a notification once your application is processed\n\n`;
								yield `*Note: The deductions (share capital, savings deposit, and service fee) are automatically calculated and will be deducted from your loan amount before disbursement.*\n\n`;
							} else {
								yield `\n\nâŒ **Error saving loan application:** ${result.message}\n\n`;
							}
						}
					}
				}

				// Extract text from the chunk
				const text = chunk.candidates?.[0]?.content?.parts?.[0]?.text;
				if (text) {
					yield text;
				}
			}
		} catch (error) {
			console.error("Error in streamPrompt:", error);
			yield "Sorry, there was an error processing your request.";
		}
	};

	const resetChat = () => {
		chatRef.current = null;
	};

	return { streamPrompt, resetChat };
}
